<html>
    <head></head>
    <style>
        .oriImg {
            display: none;
        }

        canvas {
            height: 200px;
        }
    </style>
    <body>
    <div id="app"></div>
    <script src="plugins/vue.js"></script>
    <script src="plugins/moment.min.js"></script>
    <script type="text/javascript">
        const app = document.getElementById('app');
        const config = {
            dateRange: [-7, 0],
            subImageMax: 10,
            fileExtension: 'jpg',
            filenameFormat: 'MMDD',
            fileFolder: 'imgs',
            weekSplit: [[0, 1, 2, 3], [4, 5, 6]],
            waterMarkColor: [
                ['#A349A4', '#FF7F27'],
                ['#3F48CC', '#880015'],
                ['#7092BE', '#22B14C'],
                ['#7F7F7F', '#7092BE'],
            ],
        };

        function generateTargetDates(startDays, endDays) {
            let startDate = moment().add(startDays, 'days');
            let endDate = moment().add(endDays, 'days');
            let days = [];
            while (!startDate.isAfter(endDate)) {
                days.push(startDate.format(config.filenameFormat));
                startDate.add(1, 'days');
            }

            return days;
        }

        function getSearchImageCount() {
            return (config.dateRange[1] - config.dateRange[0] + 1) * (config.subImageMax + 1);
        }

        function createImage(filename, group) {
            let image = document.createElement('img');
            image.src = config.fileFolder + '/' + filename + '.' + config.fileExtension;
            image.classList.add('oriImg');
            image.onload = () => {
                imageLoadTried++;
                if (!imageGroup[group]) {
                    imageGroup[group] = [];
                }

                imageGroup[group].push(image);
                if (imageLoadTried === imageTotal) {
                    handleImageGroups();
                }
            };

            image.onerror = () => {
                imageLoadTried++;
                if (imageLoadTried === imageTotal) {
                    handleImageGroups();
                }
            };

            app.appendChild(image);
        }

        function handleImageGroups() {
            Object.keys(imageGroup).forEach(day => {
                let groupContainer = document.createElement('div');
                let groupTitle = document.createElement('div');
                groupTitle.innerText = day;

                let canvas = document.createElement('canvas');
                let images = imageGroup[day];
                let sqrt = Math.sqrt(images.length);
                let widthRate = Math.ceil(sqrt);
                canvas.width = images[0].width * widthRate;
                let sqrtFloor = Math.floor(sqrt);
                if (images.length - Math.pow(sqrtFloor, 2) > sqrtFloor) {
                    canvas.height = images[0].height * (sqrtFloor + 1);
                } else {
                    canvas.height = images[0].height * sqrtFloor;
                }

                let context = canvas.getContext('2d');
                imageCombineAlgorithm(images, context);
                const waterMarkInfo = parseDayWaterMarkInfo(day);
                addingWaterMark(
                    context,
                    waterMarkInfo.waterMarkText,
                    waterMarkInfo.waterMarkColor,
                    canvas.width,
                    canvas.height,
                    widthRate
                );

                groupContainer.appendChild(groupTitle);
                groupContainer.appendChild(canvas);
                app.appendChild(groupContainer);
            });
        }

        function addingWaterMark(context, text, color, width, height, widthRate) {
            console.log('addingWaterMark');
            context.beginPath();
            context.fillStyle  = "white";
            context.fillRect(width * 0.1, height * 0.4, width * 0.8, height * 0.15);
            let fonSize = 110;
            context.font = fonSize * widthRate + 'px serif';
            context.fillStyle = color;
            context.fillText(text, width * 0.15, height * 0.5);
        }

        function parseDayWaterMarkInfo(day) {
            let date = moment(day, config.filenameFormat);
            let dateText;
            switch (date.day()) {
                case 1:
                    dateText = '一';
                    break;
                case 2:
                    dateText = '二';
                    break;
                case 3:
                    dateText = '三';
                    break;
                case 4:
                    dateText = '四';
                    break;
                case 5:
                    dateText = '五';
                    break;
                case 6:
                    dateText = '六';
                    break;
                default:
                    dateText = '日';
                    break;
            }

            let dateSplitGroup = config.weekSplit.findIndex(group => {
                return group.includes(date.day());
            });

            return {
                waterMarkText: date.format('YYYY/MM/DD') + '(' + dateText + ')',
                waterMarkColor: config.waterMarkColor[date.week() % 4][dateSplitGroup],
            }
        }

        function imageCombineAlgorithm(images, context) {
            let biasRate = 0;
            let currentWidthRate = 0;
            let currentHeightRate = 0;
            let currentDirection = 'horizontal';

            images.forEach(img => {
                context.drawImage(img, img.width * currentWidthRate, img.height * currentHeightRate);
                if (currentDirection === 'vertical') {
                    currentHeightRate++;
                    if (currentHeightRate === biasRate) {
                        currentWidthRate = 0;
                        currentDirection = 'horizontal';
                    }
                } else {
                    currentWidthRate++;
                    if (currentWidthRate > biasRate) {
                        biasRate++;
                        currentWidthRate = biasRate;
                        currentHeightRate = 0;
                        currentDirection = 'vertical';
                    }
                }
            });
        }

        let imageLoadTried = 0;
        let imageTotal = getSearchImageCount();
        let imageGroup = {};
        let days = generateTargetDates(config.dateRange[0], config.dateRange[1]);
        days.forEach(day => {
            createImage(day, day);
            for (let i = 0; i < config.subImageMax; i++) {
                createImage(day + '-' + i, day);
            }
        });
    </script>
    </body>
</html>
